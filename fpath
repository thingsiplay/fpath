#!/usr/bin/env python3

from sys import exit, stdin
from subprocess import Popen, PIPE, DEVNULL
from shlex import split as shlex_split
from argparse import ArgumentParser
from argparse import Namespace as ArgumentNamespace
from pathlib import Path
from datetime import datetime
from stat import filemode, S_ISDIR, S_ISREG, S_ISLNK
from re import compile as re_compile
from hashlib import sha3_512
from decimal import Decimal


class fmtPath:

    home = Path.home()

    def __init__(
        self,
        input_path: str,
        absolute: bool,
        resolve: bool,
        base: Path | None,
        tilde: bool,
        quotes: str,
        leading_dot: bool,
    ) -> None:
        self.origin = input_path
        # work_path does not contain all configurations and is not intended for
        # end user. Use path_with_lazy() to calculate final state with all lazy
        # options incorporated dynamically at request time. That's because the
        # final path can contain the tilde in example, which is incompatible
        # with some operations.
        self.work_path = Path(unquote(input_path)).expanduser()

        if base is not None and not self.work_path.is_absolute():
            self.work_path = base.expanduser() / self.work_path
        if resolve:
            self.work_path = self.work_path.resolve()
        elif absolute:
            self.work_path = self.work_path.absolute()

        self.lazy_tilde: bool = tilde
        self.lazy_quotes: str = quotes
        self.with_leading_dot: bool = leading_dot
        self.exists_cache: bool | None = None
        self.symlink_cache: Path | None = None
        return

    def __str__(self) -> str:
        if (
            self.with_leading_dot
            and not self.lazy_tilde
            and not self.path.is_absolute()
        ):
            dot = "./"
        else:
            dot = ""
        return self.lazy_quotes + dot + self.path.as_posix() + self.lazy_quotes

    def __repr__(self) -> str:
        return repr(self.__str__())

    @property
    def path(self) -> Path:
        return self.path_with_lazy()

    def path_with_lazy(self) -> Path:
        path = self.work_path
        if self.lazy_tilde:
            try:
                path = "~" / path.relative_to(self.home)
            except ValueError:
                pass
        return path

    @property
    def exists(self) -> bool:
        if self.exists_cache is None:
            if self.work_path.is_symlink():
                self.exists_cache = self.work_path.exists(follow_symlinks=True)
            else:
                self.exists_cache = self.work_path.exists(follow_symlinks=False)
        return self.exists_cache

    @property
    def symlink_path(self) -> Path:
        if self.symlink_cache is None:
            try:
                self.symlink_cache = self.work_path.readlink()
            except OSError:
                self.symlink_cache = self.work_path
        return self.symlink_cache


def escape_slash(source: str, sep: str):
    return source.replace(sep, "\x04")


def unescape_slash(source: str, sep: str):
    return source.replace("\x04", sep)


# Convert style code parts into a fully functional terminal code sequence.
def encode_style_codes(text: str, start_code: str, end_code: str = "") -> str:
    if end_code == "":
        return f"\033[{start_code}m{text}"
    else:
        return f"\033[{start_code}m{text}\u001b[{end_code}m"


def terminal_style_codes_table(
    flat: bool = False,
) -> dict["str", dict["str", "str"]]:
    # Should be used with an encoder to build the final terminal code sequence.
    # Not all codes work on all terminals.
    # https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters
    table = {
        "global": {
            "": "0",
            "reset": "0",
            "default": "0",
        },
        "effects": {
            "bold": "1",
            "**": "1",
            "italic": "3",
            "*": "3",
            "dim": "2",
            "underline": "4",
            "dunderline": "21",
            "overline": "53",
            "reverse": "7",
            "=": "7",
            "strike": "9",
            "blink": "5",
            "hide": "8",
        },
        "effects off": {
            "/bold": "22",
            "/**": "22",
            "/italic": "23",
            "/*": "23",
            "/dim": "22",
            "/underline": "24",
            "/dunderline": "24",
            "/overline": "55",
            "/reverse": "27",
            "/=": "27",
            "/strike": "29",
            "/blink": "25",
            "/hide": "28",
        },
        "foreground colors": {
            "dark": "30",
            "white": "37",
            "red": "31",
            "R": "31",
            "green": "32",
            "G": "32",
            "blue": "34",
            "B": "34",
            "yellow": "33",
            "magenta": "35",
            "cyan": "36",
        },
        "bright foreground colors": {
            "bdark": "90",
            "bwhite": "97",
            "bred": "91",
            "bgreen": "92",
            "bblue": "94",
            "byellow": "93",
            "bmagenta": "95",
            "bcyan": "96",
        },
        "background colors": {
            "bg.dark": "40",
            "bg.white": "47",
            "bg.red": "41",
            "bg.green": "42",
            "bg.blue": "44",
            "bg.yellow": "43",
            "bg.magenta": "45",
            "bg.cyan": "46",
        },
        "bright background colors": {
            "bg.bdark": "100",
            "bg.bwhite": "107",
            "bg.bred": "101",
            "bg.bgreen": "102",
            "bg.bblue": "104",
            "bg.byellow": "103",
            "bg.bmagenta": "105",
            "bg.bcyan": "106",
        },
        "colors off": {
            "/color": "39",
            "/bg.color": "49",
        },
    }
    if flat:
        inner = {}
        for _, inner_dict in table.items():
            inner.update(inner_dict)
        return inner
    return table


def supported_fmt_commands() -> dict[str, str]:
    return {
        "STYLE": "name of the style like 'green' or 'bold'",
        "center:num": "center text by padding with NUM * space",
        "left:num": "left justify text by padding with NUM * space",
        "right:num": "right justify text by padding with NUM * space",
        "fill:num": "left fill with '0', leading +- sign is preserved",
        "/center": "end marker for center",
        "/left": "end marker for left",
        "/right": "end marker for right",
        "/fill": "end marker for fill",
        "index": "current number of path in process",
        "i": "same as {index}",
        "total": "total count of paths to process",
        "origin": "original input data before processing",
        "list": "path broken up into individual parts, also {rlist}",
        "-start:end": "slice a part from path, also {rstart:end}",
        "path": "path as posix, also {rpath}",
        "root": "drive and root if any, also {rroot}",
        "uri": "path as file URI, also {ruri}",
        "dir": "parent directory path, also {rdir}",
        "dirname": "parent directory name without path, also {rdirname}",
        "name": "file name without directory, also {rname}",
        "stem": "file name without directory and extension, also {rstem}",
        "ext": "single file extension after '.', also {rext}",
        "exts": "all file extensions if more than one '.', also {rexts}",
        "file": "long type information based on file content (slow), also {rfile}",
        "type": "short type information based on file content (slow), also {rtype}",
        "mime": "short mime information based on file content (slow), also {rmime}",
        "owner": "name of owner from file, also {rowner}",
        "group": "name of group from file owner, also {rgroup}",
        ".stat": "unprocessed file stat results, also {.lstat}",
        ".mode": "file permissions, also {.lmode}",
        ".perm": "same as {.mode}, also {.lperm}",
        ".isdir": "add a true path separator character if its a directory, also {.lisdir}",
        ".isdir:text": "any text if existing directory, empty otherwise, also {.lisdir:text}",
        ".isreg:text": "any text if existing regular file, empty otherwise, also {.lisreg:text}",
        ".islink:text": "any text if existing symbolic link, empty otherwise, also {.lislink:text}",
        ".dev": "device id where this file resides, also {.ldev}",
        ".uid": "user id number from file owner, also {.luid}",
        ".gid": "group id number from file owner, also {.lgid}",
        ".nlink": "number of hard links on filesystem, also {.lnlink}",
        ".size": "auto format file size with unit, 1 rounding digit, also {.lsize}",
        ".b": "file size in bytes, also {.lb}",
        ".kb": "file size in kilobytes, 2 rounding digits, {also .lkb}",
        ".mb": "file size in megabytes, 2 rounding digits, {also .lmb}",
        ".gb": "file size in gigabytes, 2 rounding digits, {also .lgb}",
        ".atime": "last access timestamp in readable format, {also .latime}",
        ".mtime": "last modified timestamp in readable format, {also .lmtime}",
        ".ctime": "last changed timestamp in readable format, {also .lctime}",
        ".atime:args": "custom strftime format codes, {also .latime:args}",
        ".mtime:args": "custom strftime format codes, {also .lmtime:args}",
        ".ctime:args": "custom strftime format codes, {also .lctime:args}",
        "!prog:args": "run any program to replace DATA (very, VERY slow)",
        "/!": "end marker for {!prog:args}",
    }


def unescape_backslash_chars(source: str):
    if "\\" in source:
        source = source.replace(r"\\", "\\")
        source = source.replace(r"\n", "\n")
        source = source.replace(r"\t", "\t")
        source = source.replace(r"\r", "\r")
        source = source.replace(r"\b", "\b")
        source = source.replace(r"\f", "\f")
        source = source.replace(r"\s", "\xa0")
        source = source.replace(r"\q", "'")
        source = source.replace(r"\Q", '"')
    return source


def file(path: list[str], arg: str | None = None):
    cmd = ["file", "--brief"]
    if arg:
        cmd.append(arg)
    cmd.append("--")
    cmd.extend(path)
    output = Popen(cmd, stdout=PIPE, text=True).communicate()[0]
    return output.strip().split("\n")


def hash(source: str):
    h = sha3_512()
    byte_posix = source.encode()
    h.update(byte_posix)
    return h.hexdigest()


# TODO: I'm not sure about correct types produced by hexdigest()
def filetypes(source, hash_entries, arg: str | None = None):
    all_paths = [p.as_posix() for p in hash_entries.values()]
    filetypes = dict(zip(hash_entries.keys(), file(all_paths, arg)))

    output = []
    for fmt in source:
        for id, p in filetypes.items():
            if id in fmt:
                source = fmt.replace(id, p)
                output.append(source)
    return output


def run_prog(cmd: list[str], stdin_data: str | None = None) -> str:
    result = None
    if stdin_data is None:
        process = Popen(
            cmd,
            shell=False,
            stdout=PIPE,
            stderr=DEVNULL,
            text=True,
        )
        result = process.communicate()[0]
    else:
        process = Popen(
            cmd,
            shell=False,
            stdin=PIPE,
            stdout=PIPE,
            stderr=DEVNULL,
            text=True,
        )
        if process.stdin:
            process.stdin.write(stdin_data)
            result = process.communicate()[0]
            process.stdin.close()
    if result:
        return result.strip()
    else:
        return ""


class App:
    name: str = "fpath"
    version: str = "0.12"

    def __init__(self, args: ArgumentNamespace) -> None:
        self.print_version: bool = args.version
        self.paths: list[fmtPath] = []

        if args.quotes:
            self.quotes = "'"
        elif args.double_quotes:
            self.quotes = '"'
        else:
            self.quotes = ""

        input_paths: list[str] = args.path
        if not args.ignore_stdin and not stdin.isatty():
            input_paths.extend(stdin_lines())

        self.sep = args.sep
        if self.sep != "/" and self.sep != "":
            self.sep = unescape_backslash_chars(self.sep)

        # Determines if style codes with terminal color was used in -s or -F.
        # Should be set to True whenever it is used.
        self.with_style_codes = False

        self.style_codes = terminal_style_codes_table(flat=True)
        if args.sep_style in self.style_codes:
            self.with_style_codes = True
            self.sep_style = self.style_codes[args.sep_style]
        else:
            self.sep_style = None

        self.leading_dot = args.dot
        self.tilde = args.tilde

        self.paths: list[fmtPath] = [
            fmtPath(
                p,
                args.absolute,
                args.resolve,
                args.base,
                self.tilde,
                self.quotes,
                self.leading_dot,
            )
            for p in input_paths
        ]

        if args.include_ignore_case:
            self.paths = [
                p
                for p in self.paths
                if self.glob_include(p.path, args.include_ignore_case, False)
            ]

        if args.exclude_ignore_case:
            self.paths = [
                p
                for p in self.paths
                if self.glob_exclude(p.path, args.exclude_ignore_case, False)
            ]

        if args.include:
            self.paths = [
                p for p in self.paths if self.glob_include(p.path, args.include, True)
            ]

        if args.exclude:
            self.paths = [
                p for p in self.paths if self.glob_exclude(p.path, args.exclude, True)
            ]

        if args.existing:
            self.paths = [p for p in self.paths if p.exists]
        elif args.missing:
            self.paths = [p for p in self.paths if not p.exists]

        self.format = args.format
        self.no_last_lineend = args.no_last_lineend

        self.lineend = args.lineend
        if self.lineend != "\n" and self.lineend != "":
            self.lineend = unescape_backslash_chars(self.lineend)

        return

    def __iter__(self):
        num_entries = len(self.paths)
        for index, path in enumerate(self.apply_format(), start=1):
            if self.no_last_lineend and num_entries == index:
                yield str(path)
            else:
                yield str(path) + self.lineend

    def glob_include(self, path: Path, include, case_sensitive):
        for pattern in include:
            if not path.match(pattern, case_sensitive=case_sensitive):
                return False
        return True

    def glob_exclude(self, path: Path, exclude, case_sensitive) -> bool:
        for pattern in exclude:
            if path.match(pattern, case_sensitive=case_sensitive):
                return False
        return True

    def apply_format(self) -> list[fmtPath]:

        def unescape(text: str) -> str:
            return text.replace("\x02", "{").replace("\x03", "}")

        def escape(text: str) -> str:
            text = escape_slash(text, "/")
            return text.replace("{", "\x02").replace("}", "\x03")

        def escape_and_quote(text: str, is_absolute: bool) -> str:
            if self.leading_dot and not self.tilde and not is_absolute:
                leading_dot = "./"
            else:
                leading_dot = ""
            return self.quotes + escape(leading_dot + text) + self.quotes

        if self.format is None:
            return self.paths

        # Escaping the "{" and "}" is required, because file paths could
        # potentially include the exact sequence by accident. This also allows
        # us to use these characters literally for output. They are all
        # unescaped at the end.
        # Also the escape sequences with backslash should be replaced first,
        # so they cannot interfere with paths.

        # {N:N} examples: {-1:} {2:4}
        re_slice = re_compile(r"{(r)?(-?[0-9]+)?:(-?[0-9]+)?}")
        # {right:N}{/right}
        re_right = re_compile(r"{right:([0-9]+?)}(.*?){/right}")
        # {left:N}{/left}
        re_left = re_compile(r"{left:([0-9]+?)}(.*?){/left}")
        # {center:N}{/center}
        re_center = re_compile(r"{center:([0-9]+?)}(.*?){/center}")
        # {fill:N}{/fill}
        re_fill = re_compile(r"{fill:([0-9]+?)}(.*?){/fill}")
        # {.ANY} examples: {.stats} {.isdir}
        re_stats = re_compile(r"{\.[^{}]+?}")
        # {.lANY} examples: {.lstats} {.lisdir}
        re_lstats = re_compile(r"{\.l[^{}]+?}")
        # {.atime:ARGS}
        re_atime = re_compile(r"\.atime:([-+ _/%,.:a-z-A-Z0-9]+?)?}")
        # {.mtime:ARGS}
        re_mtime = re_compile(r"\.mtime:([-+ _/%,.:a-z-A-Z0-9]+?)?}")
        # {.ctime:ARGS}
        re_ctime = re_compile(r"\.ctime:([-+ _/%,.:a-z-A-Z0-9]+?)?}")
        # {.latime:ARGS}
        re_latime = re_compile(r"\.latime:([-+ _/%,.:a-z-A-Z0-9]+?)?}")
        # {.lmtime:ARGS}
        re_lmtime = re_compile(r"\.lmtime:([-+ _/%,.:a-z-A-Z0-9]+?)?}")
        # {.lctime:ARGS}
        re_lctime = re_compile(r"\.lctime:([-+ _/%,.:a-z-A-Z0-9]+?)?}")
        # {.isdir:ARGS}
        re_isdir = re_compile(r"{\.isdir:([^{}]*?)}")
        # {.isreg:ARGS}
        re_isreg = re_compile(r"{\.isreg:([^{}]*?)}")
        # {.islink:ARGS}
        re_islink = re_compile(r"{\.islink:([^{}]*?)}")
        # {.lisdir:ARGS}
        re_lisdir = re_compile(r"{\.lisdir:([^{}]*?)}")
        # {.lisreg:ARGS}
        re_lisreg = re_compile(r"{\.lisreg:([^{}]*?)}")
        # {.lislink:ARGS}
        re_lislink = re_compile(r"{\.lislink:([^{}]*?)}")

        # {!prog:args}data{!/} or {!prog}data{!/}
        #   - args is optional and will be appended as arguments to program,
        #   - data is optional and will be used as stdin to feed program,
        #   - if no data is specified, then program is called without input,
        #   - either way data is replaced by programs stdout
        re_run = re_compile(r"{!([-_a-zA-Z0-9]+?)(:([^{}]*?))?}(.*?){/!}")

        # For use as unit in size calculation.
        KB_UNIT = 1024
        MB_UNIT = KB_UNIT * 1024
        GB_UNIT = MB_UNIT * 1024

        entries = []
        hash_file_entries = {}
        hash_mime_entries = {}
        hash_type_entries = {}
        hash_rfile_entries = {}
        hash_rmime_entries = {}
        hash_rtype_entries = {}
        total_entries = len(self.paths)
        for index, entry in enumerate(self.paths):
            fmt: str = self.format

            fmt = unescape_backslash_chars(fmt)
            fmt = fmt.replace(r"\0", "\x00")
            fmt = fmt.replace(r"\{", "\x02")
            fmt = fmt.replace(r"\}", "\x03")
            fmt = fmt.replace(r"\s", "\xa0")
            fmt = fmt.replace(r"\q", "'")
            fmt = fmt.replace(r"\Q", '"')

            rposix = entry.symlink_path.as_posix()
            posix = entry.path.as_posix()
            is_absolute = entry.path.is_absolute()

            if "{i}" in fmt:
                fmt = fmt.replace("{i}", "{index}")
            if "{index}" in fmt:
                fmt = fmt.replace("{index}", str(index + 1))
            if "{total}" in fmt:
                fmt = fmt.replace("{total}", str(total_entries))
            if "{origin}" in fmt:
                fmt = fmt.replace("{origin}", escape(entry.origin))
            if "{rlist}" in fmt:
                fmt = fmt.replace(
                    "{rlist}", escape_and_quote(str(entry.symlink_path.parts), False)
                )
            if "{list}" in fmt:
                fmt = fmt.replace(
                    "{list}", escape_and_quote(str(entry.path.parts), False)
                )
            if "{rpath}" in fmt:
                fmt = fmt.replace(
                    "{rpath}",
                    escape_and_quote(rposix, is_absolute),
                )
            if "{path}" in fmt:
                fmt = fmt.replace("{path}", escape_and_quote(posix, is_absolute))
            if "{rroot}" in fmt:
                fmt = fmt.replace(
                    "{rroot}", escape_and_quote(entry.symlink_path.anchor, False)
                )
            if "{root}" in fmt:
                fmt = fmt.replace("{root}", escape_and_quote(entry.path.anchor, False))
            if "{ruri}" in fmt:
                fmt = fmt.replace(
                    "{ruri}",
                    escape_and_quote(entry.symlink_path.absolute().as_uri(), False),
                )
            if "{uri}" in fmt:
                fmt = fmt.replace(
                    "{uri}", escape_and_quote(entry.path.absolute().as_uri(), False)
                )
            if "{rdir}" in fmt:
                fmt = fmt.replace(
                    "{rdir}",
                    escape_and_quote(entry.symlink_path.parent.as_posix(), is_absolute),
                )
            if "{dir}" in fmt:
                fmt = fmt.replace(
                    "{dir}",
                    escape_and_quote(entry.path.parent.as_posix(), is_absolute),
                )
            if "{rdirname}" in fmt:
                fmt = fmt.replace(
                    "{rdirname}",
                    escape_and_quote(entry.symlink_path.parent.name, False),
                )
            if "{dirname}" in fmt:
                fmt = fmt.replace(
                    "{dirname}", escape_and_quote(entry.path.parent.name, False)
                )
            if "{rname}" in fmt:
                fmt = fmt.replace(
                    "{rname}", escape_and_quote(entry.symlink_path.name, False)
                )
            if "{name}" in fmt:
                fmt = fmt.replace("{name}", escape_and_quote(entry.path.name, False))
            if "{rstem}" in fmt:
                fmt = fmt.replace(
                    "{rstem}", escape_and_quote(entry.symlink_path.stem, False)
                )
            if "{stem}" in fmt:
                fmt = fmt.replace("{stem}", escape_and_quote(entry.path.stem, False))
            if "{rext}" in fmt:
                fmt = fmt.replace(
                    "{rext}", escape_and_quote(entry.symlink_path.suffix, False)
                )
            if "{ext}" in fmt:
                fmt = fmt.replace("{ext}", escape_and_quote(entry.path.suffix, False))
            if "{rexts}" in fmt:
                fmt = fmt.replace(
                    "{rexts}",
                    escape_and_quote("".join(entry.symlink_path.suffixes), False),
                )
            if "{exts}" in fmt:
                fmt = fmt.replace(
                    "{exts}", escape_and_quote("".join(entry.path.suffixes), False)
                )

            if "file}" in fmt:
                if "{rfile}" in fmt:
                    h = hash(rposix + f"{index}rfile")
                    hash_rfile_entries[h] = entry.symlink_path
                    fmt = fmt.replace("{rfile}", h)
                if "{file}" in fmt:
                    h = hash(posix + f"{index}file")
                    hash_file_entries[h] = entry.path
                    fmt = fmt.replace("{file}", h)

            if "type}" in fmt:
                if "{rtype}" in fmt:
                    h = hash(rposix + f"{index}rtype")
                    hash_rtype_entries[h] = entry.symlink_path
                    fmt = fmt.replace("{rtype}", h)
                if "{type}" in fmt:
                    h = hash(posix + f"{index}type")
                    hash_type_entries[h] = entry.path
                    fmt = fmt.replace("{type}", h)

            if "mime}" in fmt:
                if "{rmime}" in fmt:
                    h = hash(rposix + f"{index}rmime")
                    hash_rmime_entries[h] = entry.symlink_path
                    fmt = fmt.replace("{rmime}", h)
                if "{mime}" in fmt:
                    h = hash(posix + f"{index}mime")
                    hash_mime_entries[h] = entry.path
                    fmt = fmt.replace("{mime}", h)

            if "owner}" in fmt:
                if "{rowner}" in fmt:
                    try:
                        fmt = fmt.replace("{rowner}", entry.symlink_path.owner())
                    except (KeyError, FileNotFoundError):
                        fmt = fmt.replace("{rowner}", "")
                if "{owner}" in fmt:
                    try:
                        fmt = fmt.replace("{owner}", entry.path.owner())
                    except (KeyError, FileNotFoundError):
                        fmt = fmt.replace("{owner}", "")

            if "group}" in fmt:
                if "{rgroup}" in fmt:
                    try:
                        fmt = fmt.replace("{rgroup}", entry.symlink_path.group())
                    except (KeyError, FileNotFoundError):
                        fmt = fmt.replace("{rgroup}", "")
                if "{group}" in fmt:
                    try:
                        fmt = fmt.replace("{group}", entry.path.group())
                    except (KeyError, FileNotFoundError):
                        fmt = fmt.replace("{group}", "")

            # lstats
            # NOTE: Make sure to be in sync with stats.
            # Also test for entry.exists directly, as this will change the state.
            if "{.l" in fmt and entry.exists:
                # https://docs.python.org/3/library/os.html#os.stat_result
                lst = entry.path.expanduser().lstat()
                if "{.lst" in fmt:
                    fmt = fmt.replace(
                        "{.lstat}", str(lst).removeprefix("os.stat_result")
                    )
                if "{.lpe" in fmt:
                    fmt = fmt.replace("{.lperm}", "{.lmode}")
                if "{.lmo" in fmt:
                    fmt = fmt.replace("{.lmode}", str(filemode(lst.st_mode)))
                if "{.lisd" in fmt:
                    if "{.lisdir}" in fmt:
                        fmt = fmt.replace("{.lisdir}", "\x04")
                    for arg in re_lisdir.findall(fmt):
                        if S_ISDIR(lst.st_mode):
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{.lisdir:" + arg + "}", repl)
                if "{.lisr" in fmt:
                    for arg in re_lisreg.findall(fmt):
                        if S_ISREG(lst.st_mode):
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{.lisreg:" + arg + "}", repl)
                if "{.lisl" in fmt:
                    for arg in re_lislink.findall(fmt):
                        if S_ISLNK(lst.st_mode):
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{.lislink:" + arg + "}", repl)
                if "{.lde" in fmt:
                    fmt = fmt.replace("{.ldev}", str(lst.st_dev))
                if "{.lui" in fmt:
                    fmt = fmt.replace("{.luid}", str(lst.st_uid))
                if "{.lgi" in fmt:
                    fmt = fmt.replace("{.lgid}", str(lst.st_gid))
                if "{.lnl" in fmt:
                    fmt = fmt.replace("{.lnlink}", str(lst.st_nlink))
                if "{.lsi" in fmt:
                    fmt = fmt.replace("{.lsize}", file_size_with_unit(lst.st_size))
                if "{.lb}" in fmt:
                    fmt = fmt.replace("{.lb}", file_size(lst.st_size))
                if "{.lkb}" in fmt:
                    fmt = fmt.replace("{.lkb}", file_size(lst.st_size, KB_UNIT))
                if "{.lmb}" in fmt:
                    fmt = fmt.replace("{.lmb}", file_size(lst.st_size, MB_UNIT))
                if "{.lgb}" in fmt:
                    fmt = fmt.replace("{.lgb}", file_size(lst.st_size, GB_UNIT))
                if "{.latime}" in fmt:
                    fmt = fmt.replace("{.latime}", time(lst.st_atime))
                if "{.lmtime}" in fmt:
                    fmt = fmt.replace("{.lmtime}", time(lst.st_mtime))
                if "{.lctime}" in fmt:
                    fmt = fmt.replace("{.lctime}", time(lst.st_ctime))
                if "{.l" in fmt:
                    if "time:" in fmt:
                        fmt = self.time_custom_arg(lst.st_atime, "la", re_latime, fmt)
                        fmt = self.time_custom_arg(lst.st_mtime, "lm", re_lmtime, fmt)
                        fmt = self.time_custom_arg(lst.st_ctime, "lc", re_lctime, fmt)
            else:
                fmt = re_lstats.sub("", fmt)

            # stats
            # NOTE: Make sure to be in sync with lstats. And do not name these
            # starting with {.l !
            # Also test for entry.exists directly, as this will change the state.
            if "{." in fmt and entry.exists:
                # https://docs.python.org/3/library/os.html#os.stat_result
                st = entry.path.expanduser().stat()
                if "{.st" in fmt:
                    fmt = fmt.replace("{.stat}", str(st).removeprefix("os.stat_result"))
                if "{.pe" in fmt:
                    fmt = fmt.replace("{.perm}", "{.mode}")
                if "{.mo" in fmt:
                    fmt = fmt.replace("{.mode}", str(filemode(st.st_mode)))
                if "{.isd" in fmt:
                    if "{.isdir}" in fmt:
                        fmt = fmt.replace("{.isdir}", "\x04")
                    for arg in re_isdir.findall(fmt):
                        if S_ISDIR(st.st_mode):
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{.isdir:" + arg + "}", repl)
                if "{.isr" in fmt:
                    for arg in re_isreg.findall(fmt):
                        if S_ISREG(st.st_mode):
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{.isreg:" + arg + "}", repl)
                if "{.isl" in fmt:
                    for arg in re_islink.findall(fmt):
                        if S_ISLNK(st.st_mode):
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{.islink:" + arg + "}", repl)
                if "{.de" in fmt:
                    fmt = fmt.replace("{.dev}", str(st.st_dev))
                if "{.ui" in fmt:
                    fmt = fmt.replace("{.uid}", str(st.st_uid))
                if "{.gi" in fmt:
                    fmt = fmt.replace("{.gid}", str(st.st_gid))
                if "{.nl" in fmt:
                    fmt = fmt.replace("{.nlink}", str(st.st_nlink))
                if "{.si" in fmt:
                    fmt = fmt.replace("{.size}", file_size_with_unit(st.st_size))
                if "{.b}" in fmt:
                    fmt = fmt.replace("{.b}", file_size(st.st_size))
                if "{.kb}" in fmt:
                    fmt = fmt.replace("{.kb}", file_size(st.st_size, KB_UNIT))
                if "{.mb}" in fmt:
                    fmt = fmt.replace("{.mb}", file_size(st.st_size, MB_UNIT))
                if "{.gb}" in fmt:
                    fmt = fmt.replace("{.gb}", file_size(st.st_size, GB_UNIT))
                if "{.atime}" in fmt:
                    fmt = fmt.replace("{.atime}", time(st.st_atime))
                if "{.mtime}" in fmt:
                    fmt = fmt.replace("{.mtime}", time(st.st_mtime))
                if "{.ctime}" in fmt:
                    fmt = fmt.replace("{.ctime}", time(st.st_ctime))
                if "{." in fmt:
                    if "time:" in fmt:
                        fmt = self.time_custom_arg(st.st_atime, "a", re_atime, fmt)
                        fmt = self.time_custom_arg(st.st_mtime, "m", re_mtime, fmt)
                        fmt = self.time_custom_arg(st.st_ctime, "c", re_ctime, fmt)
            else:
                fmt = re_stats.sub("", fmt)

            # styles: {red}
            if "{/}" in fmt:
                fmt = fmt.replace("{/}", "{/color}{/bg.color}")
            if "{" in fmt:
                for name, code in self.style_codes.items():
                    style_cmd = "{" + name + "}"
                    if style_cmd in fmt:
                        self.with_style_codes = True
                        fmt = fmt.replace(style_cmd, encode_style_codes("", str(code)))

            # index and slices
            if "{" in fmt:
                if ":" in fmt:
                    match = re_slice.findall(fmt)
                else:
                    match = None
                if match:
                    parts = entry.path.parts
                    rparts = entry.symlink_path.parts
                    # slices: {2:-1}
                    for i in match:

                        if i[1] == "":
                            start = None
                        else:
                            start = int(i[1])
                        if i[2] == "":
                            end = None
                        else:
                            end = int(i[2])

                        if i[0] == "r":
                            slice = rparts[start:end]
                        else:
                            slice = parts[start:end]

                        if i[1] == "":
                            start = ""
                        if i[2] == "":
                            end = ""

                        if i[0] == "r":
                            key = "{r" + f"{start}:{end}" + "}"
                        else:
                            key = "{" + f"{start}:{end}" + "}"

                        fmt = fmt.replace(
                            key,
                            escape_and_quote(
                                "/".join(slice).replace("//", "/", 1), False
                            ),
                        )

            if "{right:" in fmt:
                for m in re_right.findall(fmt):
                    count = m[0]
                    content = m[1]
                    fmt = fmt.replace(
                        "{right:" + count + "}" + content + "{/right}",
                        content.rjust(int(count), " "),
                        1,
                    )

            if "{left:" in fmt:
                for m in re_left.findall(fmt):
                    count = m[0]
                    content = m[1]
                    fmt = fmt.replace(
                        "{left:" + count + "}" + content + "{/left}",
                        content.ljust(int(count), " "),
                        1,
                    )

            if "{center:" in fmt:
                for m in re_center.findall(fmt):
                    count = m[0]
                    content = m[1]
                    fmt = fmt.replace(
                        "{center:" + count + "}" + content + "{/center}",
                        content.center(int(count), " "),
                        1,
                    )

            if "{fill:" in fmt:
                for m in re_fill.findall(fmt):
                    count = m[0]
                    content = m[1]
                    fmt = fmt.replace(
                        "{fill:" + count + "}" + content + "{/fill}",
                        content.zfill(int(count)),
                        1,
                    )

            # {!prog:args}DATA{/!}
            # {!prog}{/!}
            if "{!" in fmt:
                for m in re_run.findall(fmt):
                    prog = m[0]
                    args = m[2]
                    stdin_data = m[3]
                    cmd: list[str] = [prog] + shlex_split(args)
                    un_cmd = [unescape_slash(unescape(c), self.sep) for c in cmd]
                    output: str = ""
                    if stdin_data == "":
                        output = run_prog(un_cmd)
                    else:
                        un_stdin_data = unescape_slash(unescape(stdin_data), self.sep)
                        output = run_prog(un_cmd, un_stdin_data)
                    un_output = unescape_slash(unescape(output), self.sep)
                    if m[1] == "":
                        call = prog
                    else:
                        call = f"{prog}:{args}"
                    fmt = fmt.replace(
                        "{!" + f"{call}" + "}" + stdin_data + "{/!}", un_output
                    )

            entries.append(unescape(fmt))

        if hash_file_entries:
            entries = filetypes(entries, hash_file_entries)
        if hash_type_entries:
            entries = filetypes(entries, hash_type_entries, "--mime-type")
        if hash_mime_entries:
            entries = filetypes(entries, hash_mime_entries, "--mime-encoding")
        if hash_rfile_entries:
            entries = filetypes(entries, hash_rfile_entries)
        if hash_rtype_entries:
            entries = filetypes(entries, hash_rtype_entries, "--mime-type")
        if hash_rmime_entries:
            entries = filetypes(entries, hash_rmime_entries, "--mime-encoding")

        return entries

    def stylize_sep(self, source: str) -> str:
        if self.format:
            origin_sep = "\x04"
        else:
            origin_sep = "/"

        if self.sep_style:
            source = source.replace(
                origin_sep, encode_style_codes(str(self.sep), str(self.sep_style), "0")
            )
        else:
            source = source.replace(origin_sep, str(self.sep))

        if self.with_style_codes:
            source += encode_style_codes("", "0")
        return source

    # https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
    def time_custom_arg(self, seconds: float, prefix: str, regex, source: str) -> str:
        for match in regex.finditer(source):
            args = match.group(1)
            if args is None:
                args = ""
            source = source.replace(
                "{." + prefix + "time:" + args + "}",
                datetime.fromtimestamp(seconds).strftime(args),
            )
        return source

    def help_explain_style(self, compact: bool = False) -> None:
        if not compact:
            print(
                r"""List of style names

-s can use only one style, while -F can mix and match multiple styles. Using
styles with -s option will overwrite color and style changes from -F.

    -s "red"

    -sblink

There are a few shortcuts available, with same meaning as the normal style
commands:

    {}          as default
    {**} {/**}  as bold
    {*} {/*}    as italic
    {=} {/=}    as reverse
    {R}         as red
    {G}         as green
    {B}         as blue
    {/}         as /color and /bg.color

-F supports styles too. More about this option with -H fmt.

    -F{red}

    -F"Hyper {blink}HYPER{/blink}{default}"
"""
            )
        for header, names in terminal_style_codes_table().items():
            if compact:
                print(f"{header}:", ", ".join(names.keys()), end="\n")
            else:
                print(f"\n{header}")
                keys = ""
                for k in names.keys():
                    keys += "\t{" + k + "}\n"
                print(keys, end="")
        return

    def help_explain_fmt(self, compact: bool = False) -> None:
        if not compact:
            print(
                r"""List of format commands

-F requires curly braces to recognize format commands. -F will stop printing
paths by default and give full control of output. All style commands are also
available. When using color or other styles, then make sure to close the tag,
otherwise it will spill over to next line:

    -F{name}={path}

    -F '{byellow}{name}{/color}'

Resolve path to symbolic links target with the resolve variant, adding "r" in
front of a path command:

    -F{rname}={rpath}

All stat based commands starting with a dot "{." will automatically expand any
symbolic link to its target. To get information about the link file itself, add
an "l" after the dot:

    -F '{.size} - {.lsize}'

Some commands accept arguments. The arguments are inside the curly braces,
separated by double colon in the form "{command:arguments}":

    -F '{.atime:%Y-%m-%d}'

    -F '{center:70} text {/center}'

Slices in form "{start:end}" are two numbers to output only part of a path.
Start index begins count at 0 for element 1. End index starts counting at 1 for
first element and should be higher than Start index. Negative numbers start
counting backwards from last element. Empty values means rest of the path.

    -F {1:2}

    -F {-2:}

Output result from any application with the run command. Base structure is
"{!prog:args} DATA {/!}":

    - "prog" is the name of the program
    - "args" are optional arguments to the program
    - "DATA" is optional text send to the programs stdin stream

If DATA is given, then this will be used as stdin for the calling program, and
is replaced by the stdout result. If no DATA is specified, then program runs
without stdin stream. After execution of program its stdout will be printed.

    -F '{!grep:-i Car}{path}{/!}'

    -F '{!sed:"s/home/hell"}{path}{/!}'

    -F '{!md5sum:"{path}"}{/!}'

All style commands are also available. List them with -H style.

In addition following control sequences are translated into their "real"
meaning:

    "\\" to literal single slash "\"
    "\{" to literal "{"
    "\}" to literal "}"
    "\q" to literal single quote '
    "\Q" to literal double quote "
    "\n" to newline
    "\t" to tab
    "\r" to carriage return
    "\f" to form feed
    "\b" to backspace
    "\s" to non breakable space

"""
            )
        for key, value in supported_fmt_commands().items():
            if compact:
                print(f"{key}:", value.replace("{", "").replace("}", ""))
            else:
                print("{" + key + "}")
                print(f"\t{value}\n")
        return


def file_size_with_unit(bytes: float) -> str:
    unit = "B"
    dbytes = Decimal(bytes)
    if dbytes > 1024:
        dbytes = dbytes / 1024
        unit = "KB"
    if dbytes > 1024:
        dbytes = dbytes / 1024
        unit = "MB"
    if dbytes > 1024:
        dbytes = dbytes / 1024
        unit = "GB"
    return f"{round(dbytes, 1)} {unit}"


def file_size(bytes: float, unit: int | None = None) -> str:
    if unit is None:
        return str(bytes)
    dbytes = Decimal(bytes)
    if unit is not None:
        dbytes = dbytes / unit
    return str(round(dbytes, 2))


def time(seconds: float) -> str:
    return datetime.fromtimestamp(seconds).strftime("%A, %B %d, %Y %I:%M:%S")


def unquote(path: str) -> str:
    if path.startswith("'") and path.endswith("'"):
        path = path[1:]
        path = path[:-1]
    elif path.startswith('"') and path.endswith('"'):
        path = path[1:]
        path = path[:-1]
    return path


def stdin_lines() -> list[str]:
    lines: list[str] = []
    for line in stdin.readlines():
        if line:
            lines.extend(line.split("\n"))
    return [line for line in lines if not line == ""]


def parse_arguments() -> ArgumentNamespace:
    parser = ArgumentParser(
        description="Reformat and stylize file path like text output.",
        epilog=("Copyright Â© 2024 Tuncay D. <https://github.com/thingsiplay/fpath>"),
    )

    _ = parser.add_argument(
        "path",
        default=[],
        nargs="*",
        help="file or directory as textual input to operate on the path",
    )

    _ = parser.add_argument(
        "--version",
        default=False,
        action="store_true",
        help="print version and exit",
    )

    choices = ["style", "style_compact", "fmt", "fmt_compact"]
    _ = parser.add_argument(
        "-H",
        "--explain",
        metavar="SUB",
        choices=choices,
        help=f"Subjects: {', '.join(choices)}",
    )

    _ = parser.add_argument(
        "-F",
        "--format",
        metavar="FMT",
        default=None,
        help="construct output with variables and control sequences",
    )

    _ = parser.add_argument(
        "-/",
        "--sep",
        metavar="STR",
        default="/",
        help="replace the default path separateor slash with an arbitrary text",
    )

    _ = parser.add_argument(
        "-s",
        "--sep-style",
        metavar="NAME",
        help="emphasize and change color of path separator",
    )

    _ = parser.add_argument(
        "-l",
        "--lineend",
        metavar="STR",
        default="\n",
        help="text to output as each line ending, defaults to newline character",
    )

    _ = parser.add_argument(
        "-n",
        "--no-last-lineend",
        default=False,
        action="store_true",
        help="do not put trailing lineend from -l for the last output file",
    )

    _ = parser.add_argument(
        "-b",
        "--base",
        metavar="DIR",
        type=Path,
        help="base directory to put in front of each relative path",
    )

    absolute_group = parser.add_mutually_exclusive_group()

    _ = absolute_group.add_argument(
        "-a",
        "--absolute",
        default=False,
        action="store_true",
        help="expand relative to absolute by current working dir, do not normalize",
    )

    _ = absolute_group.add_argument(
        "-r",
        "--resolve",
        default=False,
        action="store_true",
        help="expand relative to absolute, normalize '.', '..' and follow symlinks",
    )

    _ = parser.add_argument(
        "-t",
        "--tilde",
        default=False,
        action="store_true",
        help="display users home directory as tilde '~/'",
    )

    _ = parser.add_argument(
        "-d",
        "--dot",
        default=False,
        action="store_true",
        help="display unresolved relative paths with a leading dot './'",
    )

    quotes_group = parser.add_mutually_exclusive_group()

    _ = quotes_group.add_argument(
        "-q",
        "--quotes",
        default=False,
        action="store_true",
        help="enclose all paths by surrounding single quotes ''",
    )

    _ = quotes_group.add_argument(
        "-Q",
        "--double-quotes",
        default=False,
        action="store_true",
        help='enclose all paths by surrounding double quotes ""',
    )

    existing_group = parser.add_mutually_exclusive_group()

    _ = existing_group.add_argument(
        "-e",
        "--existing",
        default=False,
        action="store_true",
        help="process only paths pointing to existing files and folders",
    )

    _ = existing_group.add_argument(
        "-m",
        "--missing",
        default=False,
        action="store_true",
        help="exclude existing files and folders",
    )

    _ = parser.add_argument(
        "-i",
        "--include-ignore-case",
        metavar="GLOB",
        default=[],
        nargs="*",
        action="extend",
        help="case-insensitive wildcard pattern, process matching names only",
    )

    _ = parser.add_argument(
        "-I",
        "--include",
        metavar="GLOB",
        default=[],
        nargs="*",
        action="extend",
        help="same as option -i, but case sensitive",
    )

    _ = parser.add_argument(
        "-x",
        "--exclude-ignore-case",
        metavar="GLOB",
        default=[],
        nargs="*",
        action="extend",
        help="case-insensitive wildcard pattern, exclude matching names",
    )

    _ = parser.add_argument(
        "-X",
        "--exclude",
        metavar="GLOB",
        default=[],
        nargs="*",
        action="extend",
        help="same as option -x, but case sensitive",
    )

    _ = parser.add_argument(
        "-z",
        "--ignore-stdin",
        default=False,
        action="store_true",
        help="do not read from newline separated stdin stream as path",
    )

    return parser.parse_args()


def main():
    args: ArgumentNamespace = parse_arguments()

    app = App(args)

    if app.print_version:
        print(f"{app.name} v{app.version}")
        return 0

    if args.explain:
        if args.explain == "style":
            app.help_explain_style(compact=False)
        elif args.explain == "style_compact":
            app.help_explain_style(compact=True)
        elif args.explain == "fmt":
            app.help_explain_fmt(compact=False)
        elif args.explain == "fmt_compact":
            app.help_explain_fmt(compact=True)
        return 0

    output = ""
    for path in app:
        output += path
    output = app.stylize_sep(output)
    print(output, end="")

    return 0


if __name__ == "__main__":
    exit(main())
