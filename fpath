#!/usr/bin/env python3

from sys import exit, stdin
from subprocess import Popen, PIPE, DEVNULL
from shlex import split as shlex_split
from argparse import ArgumentParser
from argparse import Namespace as ArgumentNamespace
from pathlib import Path
from datetime import datetime
from stat import filemode, S_ISDIR, S_ISREG, S_ISLNK
from re import compile as re_compile
from hashlib import sha3_512
from decimal import Decimal


class fmtPath:

    home = Path.home()

    def __init__(
        self,
        input_path: str,
        absolute: bool,
        resolve: bool,
        base: Path | None,
        tilde: bool,
        quotes: str,
        leading_dot: bool,
    ) -> None:
        self.origin = input_path
        # work_path does not contain all configurations and is not intended for
        # end user. Use path_with_lazy() to calculate final state with all lazy
        # options incorporated dynamically at request time. That's because the
        # final path can contain the tilde in example, which is incompatible
        # with some operations.
        self.work_path = Path(unquote(input_path)).expanduser()

        if base is not None and not self.work_path.is_absolute():
            self.work_path = base.expanduser() / self.work_path
        if resolve:
            self.work_path = self.work_path.resolve()
        elif absolute:
            self.work_path = self.work_path.absolute()

        self.lazy_tilde: bool = tilde
        self.lazy_quotes: str = quotes
        self.with_leading_dot: bool = leading_dot
        self.exists_cache: bool | None = None
        return

    def __str__(self) -> str:
        if (
            self.with_leading_dot
            and not self.lazy_tilde
            and not self.path.is_absolute()
        ):
            dot = "./"
        else:
            dot = ""
        return self.lazy_quotes + dot + self.path.as_posix() + self.lazy_quotes

    def __repr__(self) -> str:
        return repr(self.__str__())

    @property
    def path(self) -> Path:
        return self.path_with_lazy()

    def path_with_lazy(self) -> Path:
        path = self.work_path
        if self.lazy_tilde:
            try:
                path = "~" / path.relative_to(self.home)
            except ValueError:
                pass
        return path

    @property
    def exists(self) -> bool:
        if self.exists_cache is None:
            self.exists_cache = self.work_path.exists()
        return self.exists_cache


def escape_slash(source: str, sep: str):
    return source.replace(sep, "\x04")


def unescape_slash(source: str, sep: str):
    return source.replace("\x04", sep)


# Convert style code parts into a fully functional terminal code sequence.
def encode_style_codes(text: str, start_code: str, end_code: str = "") -> str:
    if end_code == "":
        return f"\033[{start_code}m{text}"
    else:
        return f"\033[{start_code}m{text}\u001b[{end_code}m"


def terminal_style_codes_table(
    flat: bool = False,
) -> dict["str", dict["str", "str"]]:
    # Should be used with an encoder to build the final terminal code sequence.
    # Not all codes work on all terminals.
    # https://en.wikipedia.org/wiki/ANSI_escape_code#SGR_(Select_Graphic_Rendition)_parameters
    table = {
        "global": {
            "": "0",
            "reset": "0",
            "default": "0",
        },
        "effects": {
            "bold": "1",
            "**": "1",
            "italic": "3",
            "*": "3",
            "dim": "2",
            "underline": "4",
            "dunderline": "21",
            "overline": "53",
            "reverse": "7",
            "=": "7",
            "strike": "9",
            "blink": "5",
            "hide": "8",
        },
        "effects off": {
            "/bold": "22",
            "/**": "22",
            "/italic": "23",
            "/*": "23",
            "/dim": "22",
            "/underline": "24",
            "/dunderline": "24",
            "/overline": "55",
            "/reverse": "27",
            "/=": "27",
            "/strike": "29",
            "/blink": "25",
            "/hide": "28",
        },
        "foreground colors": {
            "dark": "30",
            "white": "37",
            "red": "31",
            "R": "31",
            "green": "32",
            "G": "32",
            "blue": "34",
            "B": "34",
            "yellow": "33",
            "magenta": "35",
            "cyan": "36",
        },
        "bright foreground colors": {
            "bdark": "90",
            "bwhite": "97",
            "bred": "91",
            "bgreen": "92",
            "bblue": "94",
            "byellow": "93",
            "bmagenta": "95",
            "bcyan": "96",
        },
        "background colors": {
            "bg.dark": "40",
            "bg.white": "47",
            "bg.red": "41",
            "bg.green": "42",
            "bg.blue": "44",
            "bg.yellow": "43",
            "bg.magenta": "45",
            "bg.cyan": "46",
        },
        "bright background colors": {
            "bg.bdark": "100",
            "bg.bwhite": "107",
            "bg.bred": "101",
            "bg.bgreen": "102",
            "bg.bblue": "104",
            "bg.byellow": "103",
            "bg.bmagenta": "105",
            "bg.bcyan": "106",
        },
        "colors off": {
            "/color": "39",
            "/bg.color": "49",
        },
    }
    if flat:
        inner = {}
        for _, inner_dict in table.items():
            inner.update(inner_dict)
        return inner
    return table


def supported_fmt_commands() -> dict[str, str]:
    return {
        "q": "literal single quote '",
        "Q": 'literal double quote "',
        "STYLE": "name of the style like 'green' or 'bold'",
        "center:num": "center text by padding with NUM * space",
        "left:num": "left justify text by padding with NUM * space",
        "right:num": "right justify text by padding with NUM * space",
        "fill:num": "left fill with '0', leading +- sign is preserved",
        "/center": "end marker for center",
        "/left": "end marker for left",
        "/right": "end marker for right",
        "/fill": "end marker for fill",
        "origin": "original input data before processing",
        "list": "path broken up into individual parts",
        "0..9": "direct access each part with index, from {0} to {9}",
        "-start:end": "slice from any to any index, including negative numbers",
        "index": "current number of path in process",
        "i": "same as {index}",
        "total": "total count of paths to process",
        "path": "path as posix",
        "root": "drive and root if any",
        "uri": "path as file URI",
        "dir": "parent directory path",
        "dirname": "parent directory name without path",
        "name": "file name without directory",
        "stem": "file name without directory and extension",
        "ext": "single file extension after '.'",
        "exts": "all file extensions if more than one '.'",
        "file": "long type information based on file content (slow)",
        "type": "short type information based on file content (slow)",
        "mime": "short mime information based on file content (slow)",
        "owner": "name of owner from file",
        "group": "name of group from file owner",
        "isvalid": "1=if existing on disk, 0=if not",
        "isnotvalid": "1=if does not existing on disk, 0=if it does",
        "isvalid:text": "any text if path points to exists, empty otherwise",
        "isnotvalid:text": "any text if path does not exist, empty otherwise",
        ".stat": "unprocessed file stat results",
        ".mode": "file permissions",
        ".perm": "same as {.mode}",
        ".isdir": "add a true path separator character if its a directory",
        ".isdir:text": "any text if existing directory, empty otherwise",
        ".isreg:text": "any text if existing regular file, empty otherwise",
        ".islink:text": "any text if existing symbolic link, empty otherwise",
        ".dev": "device id where this file resides",
        ".uid": "user id number from file owner",
        ".gid": "group id number from file owner",
        ".nlink": "number of hard links on filesystem",
        ".size": "auto format file size with unit, 1 rounding digit",
        ".b": "file size in bytes",
        ".kb": "file size in kilobytes, 2 rounding digits",
        ".mb": "file size in megabytes, 2 rounding digits",
        ".gb": "file size in gigabytes, 2 rounding digits",
        ".atime": "last access timestamp in readable format",
        ".mtime": "last modified timestamp in readable format",
        ".ctime": "last changed timestamp in readable format",
        ".atime:args": "custom strftime format codes",
        ".mtime:args": "custom strftime format codes",
        ".ctime:args": "custom strftime format codes",
        ".lstat": "same as {.stat}, but do not follow links",
        ".lmode": "same as {.mode}, but do not follow links",
        ".lperm": "same as {.perm}, but do not follow links",
        ".lisdir": "same as {.isdir}, but do not follow links",
        ".lisdir:text": "same as {.isdir:text}, but do not follow links",
        ".lisreg:text": "same as {.isreg:text}, but do not follow links",
        ".lislink:text": "same as {.islink:text}, but do not follow links",
        ".ldev": "same as {.dev}, but do not follow links",
        ".luid": "same as {.uid}, but do not follow links",
        ".lgid": "same as {.gid}, but do not follow links",
        ".lnlink": "same as {.nlink}, but do not follow links",
        ".lsize": "same as {.size}, but do not follow links",
        ".lb": "same as {.b}, but do not follow links",
        ".lkb": "same as {.kb}, but do not follow links",
        ".lmb": "same as {.mb}, but do not follow links",
        ".lgb": "same as {.gb}, but do not follow links",
        ".latime": "same as {.atime}, but do not follow links",
        ".lmtime": "same as {.mtime}, but do not follow links",
        ".lctime": "same as {.ctime}, but do not follow links",
        ".latime:args": "same as {.atime:args}, but do not follow links",
        ".lmtime:args": "same as {.mtime:args}, but do not follow links",
        ".lctime:args": "same as {.ctime:args}, but do not follow links",
        "!prog:args": "run any program to replace DATA (very, VERY slow)",
        "/!": "end marker for !",
    }


def unescape_backslash_chars(source: str):
    if "\\" in source:
        source = source.replace(r"\\", "\\")
        source = source.replace(r"\n", "\n")
        source = source.replace(r"\t", "\t")
        source = source.replace(r"\r", "\r")
        source = source.replace(r"\b", "\b")
        source = source.replace(r"\f", "\f")
    return source


def file(path: list[str], arg: str | None = None):
    cmd = ["file", "--brief"]
    if arg:
        cmd.append(arg)
    cmd.append("--")
    cmd.extend(path)
    output = Popen(cmd, stdout=PIPE, text=True).communicate()[0]
    return output.strip().split("\n")


def hash(source: str):
    h = sha3_512()
    byte_posix = source.encode()
    h.update(byte_posix)
    return h.hexdigest()


# TODO: I'm not sure about correct types produced by hexdigest()
def filetypes(source, hash_entries, arg: str | None = None):
    all_paths = [p.path.as_posix() for p in hash_entries.values()]
    filetypes = dict(zip(hash_entries.keys(), file(all_paths, arg)))

    output = []
    for fmt in source:
        for id, p in filetypes.items():
            if id in fmt:
                source = fmt.replace(id, p)
                output.append(source)
    return output


def run_prog(cmd: list[str], stdin_data: str | None = None) -> str:
    result = None
    if stdin_data is None:
        process = Popen(
            cmd,
            shell=False,
            stdout=PIPE,
            stderr=DEVNULL,
            text=True,
        )
        result = process.communicate()[0]
    else:
        process = Popen(
            cmd,
            shell=False,
            stdin=PIPE,
            stdout=PIPE,
            stderr=DEVNULL,
            text=True,
        )
        if process.stdin:
            process.stdin.write(stdin_data)
            result = process.communicate()[0]
            process.stdin.close()
    if result:
        return result.strip()
    else:
        return ""


class App:
    name: str = "fpath"
    version: str = "0.9"

    def __init__(self, args: ArgumentNamespace) -> None:
        self.print_version: bool = args.version
        self.paths: list[fmtPath] = []

        if args.quotes:
            self.quotes = "'"
        elif args.double_quotes:
            self.quotes = '"'
        else:
            self.quotes = ""

        input_paths: list[str] = args.path
        if not args.ignore_stdin and not stdin.isatty():
            input_paths.extend(stdin_lines())

        self.sep = args.sep
        if self.sep != "/" and self.sep != "":
            self.sep = unescape_backslash_chars(self.sep)

        # Determines if style codes with terminal color was used in -s or -F.
        # Should be set to True whenever it is used.
        self.with_style_codes = False

        self.style_codes = terminal_style_codes_table(flat=True)
        if args.sep_style in self.style_codes:
            self.with_style_codes = True
            self.sep_style = self.style_codes[args.sep_style]
        else:
            self.sep_style = None

        self.leading_dot = args.dot
        self.tilde = args.tilde

        self.paths: list[fmtPath] = [
            fmtPath(
                p,
                args.absolute,
                args.resolve,
                args.base,
                self.tilde,
                self.quotes,
                self.leading_dot,
            )
            for p in input_paths
        ]

        self.include = args.include
        if args.include:
            self.paths = [p for p in self.paths if self.glob_include(p.path)]
        else:
            self.include = []

        self.exclude = args.exclude
        if args.exclude:
            self.paths = [p for p in self.paths if self.glob_exclude(p.path)]
        else:
            self.exclude = []

        if args.existing:
            self.paths = [p for p in self.paths if p.exists]
        elif args.missing:
            self.paths = [p for p in self.paths if not p.exists]

        self.format = args.format
        self.no_last_lineend = args.no_last_lineend

        self.lineend = args.lineend
        if self.lineend != "\n" and self.lineend != "":
            self.lineend = unescape_backslash_chars(self.lineend)

        return

    def __iter__(self):
        num_entries = len(self.paths)
        for index, path in enumerate(self.apply_format(), start=1):
            if self.no_last_lineend and num_entries == index:
                yield str(path)
            else:
                yield str(path) + self.lineend

    def glob_include(self, path: Path):
        for pattern in self.include:
            if not path.match(pattern):
                return False
        return True

    def glob_exclude(self, path: Path) -> bool:
        for pattern in self.exclude:
            if path.match(pattern):
                return False
        return True

    def apply_format(self) -> list[fmtPath]:

        def unescape(text: str) -> str:
            return text.replace("\x02", "{").replace("\x03", "}")

        def escape(text: str) -> str:
            text = escape_slash(text, "/")
            return text.replace("{", "\x02").replace("}", "\x03")

        def escape_and_quote(text: str, is_absolute: bool) -> str:
            if self.leading_dot and not self.tilde and not is_absolute:
                leading_dot = "./"
            else:
                leading_dot = ""
            return self.quotes + escape(leading_dot + text) + self.quotes

        if self.format is None:
            return self.paths

        # Escaping the "{" and "}" is required, because file paths could
        # potentially include the exact sequence by accident. This also allows
        # us to use these characters literally for output. They are all
        # unescaped at the end.
        # Also the escape sequences with backslash should be replaced first,
        # so they cannot interfere with paths.

        # {N:N} examples: {-1:} {2:4}
        re_slice = re_compile(r"{(-?[0-9]+)?:(-?[0-9]+)?}")
        # {right:N}{/right}
        re_right = re_compile(r"{right:([0-9]+?)}(.*?){/right}")
        # {left:N}{/left}
        re_left = re_compile(r"{left:([0-9]+?)}(.*?){/left}")
        # {center:N}{/center}
        re_center = re_compile(r"{center:([0-9]+?)}(.*?){/center}")
        # {fill:N}{/fill}
        re_fill = re_compile(r"{fill:([0-9]+?)}(.*?){/fill}")
        # {.ANY} examples: {.stats} {.isdir}
        re_stats = re_compile(r"{\.[^{}]+?}")
        # {isvalid:ARGS}
        re_isvalid = re_compile(r"{isvalid:([^{}]+?)}")
        # {isnotvalid:ARGS}
        re_isnotvalid = re_compile(r"{isnotvalid:([^{}]+?)}")
        # {.lANY} examples: {.lstats} {.lisdir}
        re_lstats = re_compile(r"{\.l[^{}]+?}")
        # {.atime:ARGS}
        re_atime = re_compile(r"\.atime:([-+ _/%,.:a-z-A-Z0-9]+?)?}")
        # {.mtime:ARGS}
        re_mtime = re_compile(r"\.mtime:([-+ _/%,.:a-z-A-Z0-9]+?)?}")
        # {.ctime:ARGS}
        re_ctime = re_compile(r"\.ctime:([-+ _/%,.:a-z-A-Z0-9]+?)?}")
        # {.latime:ARGS}
        re_latime = re_compile(r"\.latime:([-+ _/%,.:a-z-A-Z0-9]+?)?}")
        # {.lmtime:ARGS}
        re_lmtime = re_compile(r"\.lmtime:([-+ _/%,.:a-z-A-Z0-9]+?)?}")
        # {.lctime:ARGS}
        re_lctime = re_compile(r"\.lctime:([-+ _/%,.:a-z-A-Z0-9]+?)?}")
        # {.isdir:ARGS}
        re_isdir = re_compile(r"{\.isdir:([^{}]+?)}")
        # {.isreg:ARGS}
        re_isreg = re_compile(r"{\.isreg:([^{}]+?)}")
        # {.islink:ARGS}
        re_islink = re_compile(r"{\.islink:([^{}]+?)}")
        # {.lisdir:ARGS}
        re_lisdir = re_compile(r"{\.lisdir:([^{}]+?)}")
        # {.lisreg:ARGS}
        re_lisreg = re_compile(r"{\.lisreg:([^{}]+?)}")
        # {.lislink:ARGS}
        re_lislink = re_compile(r"{\.lislink:([^{}]+?)}")

        # {!prog:args}data{!/} or {!prog}data{!/}
        #   - args is optional and will be appended as arguments to program,
        #   - data is optional and will be used as stdin to feed program,
        #   - if no data is specified, then program is called without input,
        #   - either way data is replaced by programs stdout
        re_run = re_compile(r"{!([-_a-zA-Z0-9]+?)(:([^{}]*?))?}(.*?){/!}")

        # For use as unit in size calculation.
        KB_UNIT = 1024
        MB_UNIT = KB_UNIT * 1024
        GB_UNIT = MB_UNIT * 1024

        entries = []
        hash_file_entries = {}
        hash_mime_entries = {}
        hash_type_entries = {}
        total_entries = len(self.paths)
        for index, entry in enumerate(self.paths):
            fmt: str = self.format

            fmt = unescape_backslash_chars(fmt)
            fmt = fmt.replace(r"\0", "\x00")
            fmt = fmt.replace(r"\{", "\x02")
            fmt = fmt.replace(r"\}", "\x03")

            path = entry.path
            parts = path.parts
            posix = path.as_posix()
            is_absolute = path.is_absolute()

            if "{q}" in fmt:
                fmt = fmt.replace("{q}", "'")
            if "{Q}" in fmt:
                fmt = fmt.replace("{Q}", '"')
            if "{i}" in fmt:
                fmt = fmt.replace("{i}", "{index}")
            if "{index}" in fmt:
                fmt = fmt.replace("{index}", str(index + 1))
            if "{total}" in fmt:
                fmt = fmt.replace("{total}", str(total_entries))
            if "{origin}" in fmt:
                fmt = fmt.replace("{origin}", escape(entry.origin))
            if "{list}" in fmt:
                fmt = fmt.replace("{list}", escape_and_quote(str(parts), False))
            if "{path}" in fmt:
                fmt = fmt.replace("{path}", escape_and_quote(posix, is_absolute))
            if "{root}" in fmt:
                fmt = fmt.replace("{root}", escape_and_quote(path.anchor, False))
            if "{uri}" in fmt:
                fmt = fmt.replace(
                    "{uri}", escape_and_quote(path.absolute().as_uri(), False)
                )
            if "{dir}" in fmt:
                fmt = fmt.replace(
                    "{dir}", escape_and_quote(path.parent.as_posix(), is_absolute)
                )
            if "{dirname}" in fmt:
                fmt = fmt.replace(
                    "{dirname}", escape_and_quote(path.parent.name, False)
                )
            if "{name}" in fmt:
                fmt = fmt.replace("{name}", escape_and_quote(path.name, False))
            if "{stem}" in fmt:
                fmt = fmt.replace("{stem}", escape_and_quote(path.stem, False))
            if "{ext}" in fmt:
                fmt = fmt.replace("{ext}", escape_and_quote(path.suffix, False))
            if "{exts}" in fmt:
                fmt = fmt.replace(
                    "{exts}", escape_and_quote("".join(path.suffixes), False)
                )

            if "{file}" in fmt:
                h = hash(posix + f"{index}file")
                hash_file_entries[h] = entry
                fmt = fmt.replace("{file}", h)

            if "{type}" in fmt:
                h = hash(posix + f"{index}type")
                hash_type_entries[h] = entry
                fmt = fmt.replace("{type}", h)

            if "{mime}" in fmt:
                h = hash(posix + f"{index}mime")
                hash_mime_entries[h] = entry
                fmt = fmt.replace("{mime}", h)

            if "{owner}" in fmt:
                try:
                    fmt = fmt.replace("{owner}", path.owner())
                except (KeyError, FileNotFoundError):
                    fmt = fmt.replace("{owner}", "")

            if "{group}" in fmt:
                try:
                    fmt = fmt.replace("{group}", path.group())
                except (KeyError, FileNotFoundError):
                    fmt = fmt.replace("{group}", "")

            if "{isv" in fmt:
                if "{isvalid}" in fmt:
                    fmt = fmt.replace("{isvalid}", str(int(entry.exists)))
                elif "{isvalid:" in fmt:
                    for arg in re_isvalid.findall(fmt):
                        if entry.exists:
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{isvalid:" + arg + "}", repl)

            if "{isn" in fmt:
                if "{isnotvalid}" in fmt:
                    fmt = fmt.replace("{isnotvalid}", str(int(not entry.exists)))
                elif "{isnotvalid:" in fmt:
                    for arg in re_isnotvalid.findall(fmt):
                        if not entry.exists:
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{isnotvalid:" + arg + "}", repl)

            # lstats
            # NOTE: Make sure to be in sync with stats.
            # Also test for entry.exists directly, as this will change the state.
            if "{.l" in fmt and entry.exists:
                # https://docs.python.org/3/library/os.html#os.stat_result
                lst = path.expanduser().lstat()
                if "{.lst" in fmt:
                    fmt = fmt.replace(
                        "{.lstat}", str(lst).removeprefix("os.stat_result")
                    )
                if "{.lpe" in fmt:
                    fmt = fmt.replace("{.lperm}", "{.lmode}")
                if "{.lmo" in fmt:
                    fmt = fmt.replace("{.lmode}", str(filemode(lst.st_mode)))
                if "{.lisd" in fmt:
                    if "{.lisdir}" in fmt:
                        fmt = fmt.replace("{.lisdir}", "\x04")
                    for arg in re_lisdir.findall(fmt):
                        if S_ISDIR(lst.st_mode):
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{.lisdir:" + arg + "}", repl)
                if "{.lisr" in fmt:
                    for arg in re_lisreg.findall(fmt):
                        if S_ISREG(lst.st_mode):
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{.lisreg:" + arg + "}", repl)
                if "{.lisl" in fmt:
                    for arg in re_lislink.findall(fmt):
                        if S_ISLNK(lst.st_mode):
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{.lislink:" + arg + "}", repl)
                if "{.lde" in fmt:
                    fmt = fmt.replace("{.ldev}", str(lst.st_dev))
                if "{.lui" in fmt:
                    fmt = fmt.replace("{.luid}", str(lst.st_uid))
                if "{.lgi" in fmt:
                    fmt = fmt.replace("{.lgid}", str(lst.st_gid))
                if "{.lnl" in fmt:
                    fmt = fmt.replace("{.lnlink}", str(lst.st_nlink))
                if "{.lsi" in fmt:
                    fmt = fmt.replace("{.lsize}", file_size_with_unit(lst.st_size))
                if "{.lb}" in fmt:
                    fmt = fmt.replace("{.lb}", file_size(lst.st_size))
                if "{.lkb}" in fmt:
                    fmt = fmt.replace("{.lkb}", file_size(lst.st_size, KB_UNIT))
                if "{.lmb}" in fmt:
                    fmt = fmt.replace("{.lmb}", file_size(lst.st_size, MB_UNIT))
                if "{.lgb}" in fmt:
                    fmt = fmt.replace("{.lgb}", file_size(lst.st_size, GB_UNIT))
                if "{.latime}" in fmt:
                    fmt = fmt.replace("{.latime}", time(lst.st_atime))
                if "{.lmtime}" in fmt:
                    fmt = fmt.replace("{.lmtime}", time(lst.st_mtime))
                if "{.lctime}" in fmt:
                    fmt = fmt.replace("{.lctime}", time(lst.st_ctime))
                if "{.l" in fmt:
                    if "ltime:" in fmt:
                        fmt = self.time_custom_arg(lst.st_atime, "la", re_latime, fmt)
                        fmt = self.time_custom_arg(lst.st_mtime, "lm", re_lmtime, fmt)
                        fmt = self.time_custom_arg(lst.st_ctime, "lc", re_lctime, fmt)
            else:
                fmt = re_lstats.sub("", fmt)

            # stats
            # NOTE: Make sure to be in sync with lstats. And do not name these
            # starting with {.l !
            # Also test for entry.exists directly, as this will change the state.
            if "{." in fmt and entry.exists:
                # https://docs.python.org/3/library/os.html#os.stat_result
                st = path.expanduser().stat()
                if "{.st" in fmt:
                    fmt = fmt.replace("{.stat}", str(st).removeprefix("os.stat_result"))
                if "{.pe" in fmt:
                    fmt = fmt.replace("{.perm}", "{.mode}")
                if "{.mo" in fmt:
                    fmt = fmt.replace("{.mode}", str(filemode(st.st_mode)))
                if "{.isd" in fmt:
                    if "{.isdir}" in fmt:
                        fmt = fmt.replace("{.isdir}", "\x04")
                    for arg in re_isdir.findall(fmt):
                        if S_ISDIR(st.st_mode):
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{.isdir:" + arg + "}", repl)
                if "{.isr" in fmt:
                    for arg in re_isreg.findall(fmt):
                        if S_ISREG(st.st_mode):
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{.isreg:" + arg + "}", repl)
                if "{.isl" in fmt:
                    for arg in re_islink.findall(fmt):
                        if S_ISLNK(st.st_mode):
                            repl = arg
                        else:
                            repl = ""
                        fmt = fmt.replace("{.islink:" + arg + "}", repl)
                if "{.de" in fmt:
                    fmt = fmt.replace("{.dev}", str(st.st_dev))
                if "{.ui" in fmt:
                    fmt = fmt.replace("{.uid}", str(st.st_uid))
                if "{.gi" in fmt:
                    fmt = fmt.replace("{.gid}", str(st.st_gid))
                if "{.nl" in fmt:
                    fmt = fmt.replace("{.nlink}", str(st.st_nlink))
                if "{.si" in fmt:
                    fmt = fmt.replace("{.size}", file_size_with_unit(st.st_size))
                if "{.b}" in fmt:
                    fmt = fmt.replace("{.b}", file_size(st.st_size))
                if "{.kb}" in fmt:
                    fmt = fmt.replace("{.kb}", file_size(st.st_size, KB_UNIT))
                if "{.mb}" in fmt:
                    fmt = fmt.replace("{.mb}", file_size(st.st_size, MB_UNIT))
                if "{.gb}" in fmt:
                    fmt = fmt.replace("{.gb}", file_size(st.st_size, GB_UNIT))
                if "{.atime}" in fmt:
                    fmt = fmt.replace("{.atime}", time(st.st_atime))
                if "{.mtime}" in fmt:
                    fmt = fmt.replace("{.mtime}", time(st.st_mtime))
                if "{.ctime}" in fmt:
                    fmt = fmt.replace("{.ctime}", time(st.st_ctime))
                if "{." in fmt:
                    if "time:" in fmt:
                        fmt = self.time_custom_arg(st.st_atime, "a", re_atime, fmt)
                        fmt = self.time_custom_arg(st.st_mtime, "m", re_mtime, fmt)
                        fmt = self.time_custom_arg(st.st_ctime, "c", re_ctime, fmt)
            else:
                fmt = re_stats.sub("", fmt)

            # styles: {red}
            if "{/}" in fmt:
                fmt = fmt.replace("{/}", "{/color}{/bg.color}")
            if "{" in fmt:
                for name, code in self.style_codes.items():
                    style_cmd = "{" + name + "}"
                    if style_cmd in fmt:
                        self.with_style_codes = True
                        fmt = fmt.replace(style_cmd, encode_style_codes("", str(code)))

            # index and slices
            if "{" in fmt:
                if ":" in fmt:
                    match = re_slice.findall(fmt)
                else:
                    match = None
                if match:
                    # slices: {2:-1}
                    for i in match:

                        if i[0] == "":
                            start = None
                        else:
                            start = int(i[0])
                        if i[1] == "":
                            end = None
                        else:
                            end = int(i[1])
                        slice = parts[start:end]

                        if i[0] == "":
                            start = ""
                        if i[1] == "":
                            end = ""
                        key = "{" + f"{start}:{end}" + "}"

                        fmt = fmt.replace(
                            key,
                            escape_and_quote(
                                "/".join(slice).replace("//", "/", 1), False
                            ),
                        )
                else:
                    # index: {0}, {1}, {2} ... {9}
                    p_len = len(parts)
                    max_fmt_num = 10
                    for i in range(max_fmt_num):
                        if i == max_fmt_num:
                            break
                        iseq = "{" + str(i) + "}"
                        if i >= p_len:
                            fmt = fmt.replace(iseq, escape_and_quote("", False))
                        else:
                            fmt = fmt.replace(iseq, escape_and_quote(parts[i], False))

            if "{right:" in fmt:
                for m in re_right.findall(fmt):
                    count = m[0]
                    content = m[1]
                    fmt = fmt.replace(
                        "{right:" + count + "}" + content + "{/right}",
                        content.rjust(int(count), " "),
                        1,
                    )

            if "{left:" in fmt:
                for m in re_left.findall(fmt):
                    count = m[0]
                    content = m[1]
                    fmt = fmt.replace(
                        "{left:" + count + "}" + content + "{/left}",
                        content.ljust(int(count), " "),
                        1,
                    )

            if "{center:" in fmt:
                for m in re_center.findall(fmt):
                    count = m[0]
                    content = m[1]
                    fmt = fmt.replace(
                        "{center:" + count + "}" + content + "{/center}",
                        content.center(int(count), " "),
                        1,
                    )

            if "{fill:" in fmt:
                for m in re_fill.findall(fmt):
                    count = m[0]
                    content = m[1]
                    fmt = fmt.replace(
                        "{fill:" + count + "}" + content + "{/fill}",
                        content.zfill(int(count)),
                        1,
                    )

            # {!prog:args}DATA{/!}
            # {!prog}{/!}
            if "{!" in fmt:
                for m in re_run.findall(fmt):
                    prog = m[0]
                    args = m[2]
                    stdin_data = m[3]
                    cmd: list[str] = [prog] + shlex_split(args)
                    un_cmd = [unescape_slash(unescape(c), self.sep) for c in cmd]
                    output: str = ""
                    if stdin_data == "":
                        output = run_prog(un_cmd)
                    else:
                        un_stdin_data = unescape_slash(unescape(stdin_data), self.sep)
                        output = run_prog(un_cmd, un_stdin_data)
                    un_output = unescape_slash(unescape(output), self.sep)
                    if m[1] == "":
                        call = prog
                    else:
                        call = f"{prog}:{args}"
                    fmt = fmt.replace(
                        "{!" + f"{call}" + "}" + stdin_data + "{/!}", un_output
                    )

            entries.append(unescape(fmt))

        if hash_file_entries:
            entries = filetypes(entries, hash_file_entries)
        if hash_type_entries:
            entries = filetypes(entries, hash_type_entries, "--mime-type")
        if hash_mime_entries:
            entries = filetypes(entries, hash_mime_entries, "--mime-encoding")

        return entries

    def stylize_sep(self, source: str) -> str:
        if self.format:
            origin_sep = "\x04"
        else:
            origin_sep = "/"

        if self.sep_style:
            source = source.replace(
                origin_sep, encode_style_codes(str(self.sep), str(self.sep_style), "0")
            )
        else:
            source = source.replace(origin_sep, str(self.sep))

        if self.with_style_codes:
            source += encode_style_codes("", "0")
        return source

    # https://docs.python.org/3/library/datetime.html#strftime-and-strptime-format-codes
    def time_custom_arg(self, seconds: float, prefix: str, regex, source: str) -> str:
        for match in regex.finditer(source):
            args = match.group(1)
            if args is None:
                args = ""
            source = source.replace(
                "{." + prefix + "time:" + args + "}",
                datetime.fromtimestamp(seconds).strftime(args),
            )
        return source

    def help_explain_style(self, compact: bool = False) -> None:
        if not compact:
            print(
                r"""List of style names

-s can use only one style, while -F can mix and match multiple styles. Using
styles with -s option will overwrite color and style changes from -F.

    -s "red"
    -sblink

There are a few shortcuts available, with same meaning as the normal style
commands:

    {}          as default
    {**} {/**}  as bold
    {*} {/*}    as italic
    {=} {/=}    as reverse
    {R}         as red
    {G}         as green
    {B}         as blue
    {/}         as /color and /bg.color

-F supports styles too. More about this option with -H fmt.

    -F{red}
    -F"Hyper {blink}HYPER{/blink}{default}"
"""
            )
        for header, names in terminal_style_codes_table().items():
            if compact:
                print(f"{header}:", ", ".join(names.keys()), end="\n")
            else:
                print(f"\n{header}")
                keys = ""
                for k in names.keys():
                    keys += "\t{" + k + "}\n"
                print(keys, end="")
        return

    def help_explain_fmt(self, compact: bool = False) -> None:
        if not compact:
            print(
                r"""List of format commands

-F requires the names between in curly braces to be recognized. Also one should
reset or default at the end of the command chain, otherwise it will spill over
to the other lines. -F will stop printing paths by default and give full
control with these control sequences.

    -F{name}
    -F'{uri}\n\t{.size}\n\t{.atime}\n\t{.mode}\n'
    -F'{byellow}{name}{/color}  in  {dim}{cyan}{dirname}{default}'

Very few commands even support arguments on their own for even more
customization. Those have the format {command:arguments}. The time commands
support custom formatting in form of {.atime:strftime} .

    -F'{.atime:%Y-%m-%d}'

Slices are two numbers {2:3} to specify start and end index of a path. Negative
numbers will count from end of path instead start, like {-1:} is the name of
the file and {0:} starts from first element. An empty value means rest of the
path until last element. Values higher than 9 are also allowed with slices.

    -F'{3:-1}'

Fill type of commands have a start and end marker, and a number to define how
long the marked area should be. {center:15}text{/center} would fill both sides
with space until the area is 15 characters long. Similararly {left:num} and
{right:num} work for left and right side respectively. There is also
{fill:num}, which will just fill the left side with '0', and respect any +-
prefix sign. BTW, same kind of fill command should not be nested. 

    -F{fill:5}{/fill}{center:70}{.mode}{/center}

The stat based command starting with a dot {. will follow any symlink and
report information on the target. Note that therefore {.islink} will report if
the target of a symlink is a symlink! To get information about a link file
itself, use those starting with {.l in name, such as {.lislink to report if the
path pointing to the file itself is a symlink and not its target. Good example
to test on is the file ~/.steampid .

    -F'{.islink} != {.lislink}'

Run any program with the run command, to filter stdin data and output its
stdout. Base structure of command is {!prog:args}DATA{/!}, where prog is the
name of the program. args are arguments given over to the program and is
optional. DATA, the area between start tag and its closing tag will be used as
stdin stream to the calling program, and its stdout will replace DATA. However
if DATA area is empty, then program runs without stdin stream, but its output
will still be printed.

    -F '{!grep:-i Car}{path}{/!}'
    -F '{!sed:"s/home/hell"}{path}{/!}'
    -F '{!md5sum:"{path}"}{/!}'

All style commands are also available. List them with -H style.

In addition following control sequences are translated into their "real"
meaning:

    "\\" to literal single slash "\"
    "\{" to literal "{"
    "\}" to literal "}"
    "\n" to newline
    "\t" to tab
    "\r" to carriage return
    "\b" to backspace
    "\f" to form feed

"""
            )
        for key, value in supported_fmt_commands().items():
            if compact:
                print(f"{key}:", value)
            else:
                print("{" + key + "}")
                print(f"\t{value}\n")
        return


def file_size_with_unit(bytes: float) -> str:
    unit = "B"
    dbytes = Decimal(bytes)
    if dbytes > 1024:
        dbytes = dbytes / 1024
        unit = "KB"
    if dbytes > 1024:
        dbytes = dbytes / 1024
        unit = "MB"
    if dbytes > 1024:
        dbytes = dbytes / 1024
        unit = "GB"
    return f"{round(dbytes, 1)} {unit}"


def file_size(bytes: float, unit: int | None = None) -> str:
    if unit is None:
        return str(bytes)
    dbytes = Decimal(bytes)
    if unit is not None:
        dbytes = dbytes / unit
    return str(round(dbytes, 2))


def time(seconds: float) -> str:
    return datetime.fromtimestamp(seconds).strftime("%A, %B %d, %Y %I:%M:%S")


def unquote(path: str) -> str:
    if path.startswith("'") and path.endswith("'"):
        path = path[1:]
        path = path[:-1]
    elif path.startswith('"') and path.endswith('"'):
        path = path[1:]
        path = path[:-1]
    return path


def stdin_lines() -> list[str]:
    lines: list[str] = []
    for line in stdin.readlines():
        if line:
            lines.extend(line.split("\n"))
    return [line for line in lines if not line == ""]


def parse_arguments() -> ArgumentNamespace:
    parser = ArgumentParser(
        description="Reformat and stylize file path like text output.",
        epilog=("Copyright Â© 2024 Tuncay D. <https://github.com/thingsiplay/fpath>"),
    )

    _ = parser.add_argument(
        "path",
        default=[],
        nargs="*",
        help="file or directory as textual input to operate on the path",
    )

    _ = parser.add_argument(
        "--version",
        default=False,
        action="store_true",
        help="print version and exit",
    )

    choices = ["style", "style_compact", "fmt", "fmt_compact"]
    _ = parser.add_argument(
        "-H",
        "--explain",
        metavar="SUB",
        choices=choices,
        help=f"Subjects: {", ".join(choices)}",
    )

    _ = parser.add_argument(
        "-F",
        "--format",
        metavar="FMT",
        default=None,
        help="construct output with variables and control sequences",
    )

    _ = parser.add_argument(
        "-/",
        "--sep",
        metavar="STR",
        default="/",
        help="replace the default path separateor slash with an arbitrary text",
    )

    _ = parser.add_argument(
        "-s",
        "--sep-style",
        metavar="NAME",
        help="emphasize and change color of path separator",
    )

    _ = parser.add_argument(
        "-l",
        "--lineend",
        metavar="STR",
        default="\n",
        help="text to output as each line ending, defaults to newline character",
    )

    _ = parser.add_argument(
        "-n",
        "--no-last-lineend",
        default=False,
        action="store_true",
        help="do not put trailing lineend from -l for the last output file",
    )

    _ = parser.add_argument(
        "-b",
        "--base",
        metavar="DIR",
        type=Path,
        help="base directory to put in front of each relative path",
    )

    absolute_group = parser.add_mutually_exclusive_group()

    _ = absolute_group.add_argument(
        "-a",
        "--absolute",
        default=False,
        action="store_true",
        help="expand relative to absolute by current working dir, do not normalize",
    )

    _ = absolute_group.add_argument(
        "-r",
        "--resolve",
        default=False,
        action="store_true",
        help="expand relative to absolute, normalize '.', '..' and follow symlinks",
    )

    _ = parser.add_argument(
        "-t",
        "--tilde",
        default=False,
        action="store_true",
        help="display users home directory as tilde '~/'",
    )

    _ = parser.add_argument(
        "-d",
        "--dot",
        default=False,
        action="store_true",
        help="display unresolved relative paths with a leading dot './'",
    )

    quotes_group = parser.add_mutually_exclusive_group()

    _ = quotes_group.add_argument(
        "-q",
        "--quotes",
        default=False,
        action="store_true",
        help="enclose all paths by surrounding single quotes ''",
    )

    _ = quotes_group.add_argument(
        "-Q",
        "--double-quotes",
        default=False,
        action="store_true",
        help='enclose all paths by surrounding double quotes ""',
    )

    existing_group = parser.add_mutually_exclusive_group()

    _ = existing_group.add_argument(
        "-e",
        "--existing",
        default=False,
        action="store_true",
        help="process only paths pointing to existing files and folders",
    )

    _ = existing_group.add_argument(
        "-m",
        "--missing",
        default=False,
        action="store_true",
        help="exclude existing files and folders",
    )

    _ = parser.add_argument(
        "-i",
        "--include",
        metavar="GLOB",
        default=[],
        nargs="*",
        help="case-sensitive wildcard pattern, process matching names only",
    )

    _ = parser.add_argument(
        "-x",
        "--exclude",
        metavar="GLOB",
        default=[],
        nargs="*",
        help="case-sensitive wildcard pattern, exclude matching names",
    )

    _ = parser.add_argument(
        "-z",
        "--ignore-stdin",
        default=False,
        action="store_true",
        help="do not read from newline separated stdin stream as path",
    )

    return parser.parse_args()


def main():
    args: ArgumentNamespace = parse_arguments()

    app = App(args)

    if app.print_version:
        print(f"{app.name} v{app.version}")
        return 0

    if args.explain:
        if args.explain == "style":
            app.help_explain_style(compact=False)
        elif args.explain == "style_compact":
            app.help_explain_style(compact=True)
        elif args.explain == "fmt":
            app.help_explain_fmt(compact=False)
        elif args.explain == "fmt_compact":
            app.help_explain_fmt(compact=True)
        return 0

    output = ""
    for path in app:
        output += path
    output = app.stylize_sep(output)
    print(output, end="")

    return 0


if __name__ == "__main__":
    exit(main())
